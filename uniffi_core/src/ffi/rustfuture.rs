/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

//! [`RustFuture`] represents a [`Future`] that can be sent to the foreign code over FFI.
//!
//! This type is not instantiated directly, but via the procedural macros, such as `#[uniffi::export]`.
//!
//! # The big picture
//!
//! We implement async foreign functions using a simplified version of the Future API:
//!
//! 1. Call the scaffolding function to get a [RustFutureHandle]
//! 2a. In a loop:
//!   - Call [rust_future_poll]
//!   - Suspend the function until the [rust_future_poll] continuation function is called
//!   - If the continuation was function was called with [RustFuturePoll::Ready], then break
//!     otherwise continue.
//! 2b. If the async function is cancelled, then call [rust_future_cancel].  This causes the
//!     continuation function to be called with [RustFuturePoll::Ready] and the [RustFuture] to
//!     enter a cancelled state.
//! 3. Call [rust_future_complete] to get the result of the future.
//! 4. Call [rust_future_free] to free the future, ideally in a finally block.  This:
//!    - Releases any resources held by the future
//!    - Calls any continuation callbacks that have not been called yet
//!
//! Note: Technically, the foreign code calls the scaffolding versions of the `rust_future_*`
//! functions.  These are generated by the scaffolding macro, specially prefixed, and extern "C",
//! and manually monomorphized in the case of [rust_future_complete].  See
//! `uniffi_macros/src/setup_scaffolding.rs` for details.
//!
//! ## How does `Future` work exactly?
//!
//! A [`Future`] in Rust does nothing. When calling an async function, it just
//! returns a `Future` but nothing has happened yet. To start the computation,
//! the future must be polled. It returns [`Poll::Ready(r)`][`Poll::Ready`] if
//! the result is ready, [`Poll::Pending`] otherwise. `Poll::Pending` basically
//! means:
//!
//! > Please, try to poll me later, maybe the result will be ready!
//!
//! This model is very different than what other languages do, but it can actually
//! be translated quite easily, fortunately for us!
//!
//! But… wait a minute… who is responsible to poll the `Future` if a `Future` does
//! nothing? Well, it's _the executor_. The executor is responsible _to drive_ the
//! `Future`: that's where they are polled.
//!
//! But… wait another minute… how does the executor know when to poll a [`Future`]?
//! Does it poll them randomly in an endless loop? Well, no, actually it depends
//! on the executor! A well-designed `Future` and executor work as follows.
//! Normally, when [`Future::poll`] is called, a [`Context`] argument is
//! passed to it. It contains a [`Waker`]. The [`Waker`] is built on top of a
//! [`RawWaker`] which implements whatever is necessary. Usually, a waker will
//! signal the executor to poll a particular `Future`. A `Future` will clone
//! or pass-by-ref the waker to somewhere, as a callback, a completion, a
//! function, or anything, to the system that is responsible to notify when a
//! task is completed. So, to recap, the waker is _not_ responsible for waking the
//! `Future`, it _is_ responsible for _signaling_ the executor that a particular
//! `Future` should be polled again. That's why the documentation of
//! [`Poll::Pending`] specifies:
//!
//! > When a function returns `Pending`, the function must also ensure that the
//! > current task is scheduled to be awoken when progress can be made.
//!
//! “awakening” is done by using the `Waker`.
//!
//! [`Future`]: https://doc.rust-lang.org/std/future/trait.Future.html
//! [`Future::poll`]: https://doc.rust-lang.org/std/future/trait.Future.html#tymethod.poll
//! [`Pol::Ready`]: https://doc.rust-lang.org/std/task/enum.Poll.html#variant.Ready
//! [`Poll::Pending`]: https://doc.rust-lang.org/std/task/enum.Poll.html#variant.Pending
//! [`Context`]: https://doc.rust-lang.org/std/task/struct.Context.html
//! [`Waker`]: https://doc.rust-lang.org/std/task/struct.Waker.html
//! [`RawWaker`]: https://doc.rust-lang.org/std/task/struct.RawWaker.html

use crate::{rust_call_with_out_status, FfiConverter, FfiDefault, RustCallStatus};
use std::{
    cell::UnsafeCell,
    future::Future,
    marker::PhantomData,
    ops::Deref,
    panic,
    pin::Pin,
    sync::{
        atomic::{AtomicU8, Ordering},
        Arc, Mutex,
    },
    task::{Context, Poll, Wake},
};

/// Result code for [rust_future_poll].  This is passed to the continuation function.
#[repr(i8)]
#[derive(Debug, PartialEq, Eq)]
pub enum RustFuturePoll {
    /// The future is ready and is waiting for [rust_future_complete] to be called
    Ready = 0,
    /// The future might be ready and [rust_future_poll] should be called again
    MaybeReady = 1,
}

/// Opaque handle for a Rust future that's stored by the foreign language code
#[repr(transparent)]
pub struct RustFutureHandle(*const ());

/// Foreign callback that's passed to [rust_future_poll]
///
/// The Rust side of things calls this when the foreign side should call [rust_future_poll] and
/// continue progress on the future.
pub type RustFutureContinuation = extern "C" fn(callback_data: *const (), status: RustFuturePoll);

// === Public FFI API ===

/// Create a new [RustFutureHandle]
///
/// For each exported async function, UniFFI will create a scaffolding function that uses this to
/// create the [RustFutureHandle] to pass to the foreign code.
pub fn rust_future_new<F, T, UT>(future: F, tag: UT) -> RustFutureHandle
where
    // F is the future type returned by the exported async function.  It needs to be Send + `static
    // since it will move between threads for an indeterminate amount of time as the foreign
    // executor calls polls it and the Rust executor wakes it.  It does not need to by `Sync`,
    // since we synchronize all access to the values.
    F: Future<Output = T> + Send + 'static,
    // T is the output of the Future.  It needs to implement FfiConverter.  Also it must be Send +
    // 'static for the same reason as F.
    T: FfiConverter<UT> + Send + 'static,
    // The UniFfiTag ZST. The Send + 'static bound is to keep rustc happy.
    UT: Send + 'static,
{
    // Create a RustFuture and coerce to `Arc<dyn RustFutureFfi>`, which is what we use to
    // implement the FFI
    let future_ffi = RustFuture::new(future, tag) as Arc<dyn RustFutureFfi>;
    // Box the Arc, to convert the wide pointer into a normal sized pointer so that we can pass it
    // to the foreign code.
    let boxed_ffi = Box::new(future_ffi);
    // We can now create a RustFutureHandle
    RustFutureHandle(Box::into_raw(boxed_ffi) as *mut ())
}

/// Poll a Rust future
///
/// When the future is ready to progress the continuation will be called with the `data` value and
/// a [RustFuturePoll] value. For each [rust_future_poll] call the continuation will be called
/// exactly once.
///
/// # Safety
///
/// The [RustFutureHandle] must not previously have been passed to [rust_future_free]
pub unsafe fn rust_future_poll(
    handle: RustFutureHandle,
    continuation: RustFutureContinuation,
    data: *const (),
) {
    let future = &*(handle.0 as *mut Arc<dyn RustFutureFfi>);
    future.clone().ffi_poll(continuation, data)
}

/// Cancel a Rust future
///
/// Any current and future continuations will be immediately called with RustFuturePoll::Ready.
///
/// This is needed for languages like Swift, which continuation to wait for the continuation to be
/// called when tasks are cancelled.
///
/// # Safety
///
/// The [RustFutureHandle] must not previously have been passed to [rust_future_free]
pub unsafe fn rust_future_cancel(handle: RustFutureHandle) {
    let future = &*(handle.0 as *mut Arc<dyn RustFutureFfi>);
    future.clone().ffi_cancel()
}

/// Complete a Rust future
///
/// Note: the actually extern "C" scaffolding functions can't be generic, so we generate one for
/// each supported FFI type.
///
/// # Safety
///
/// - The [RustFutureHandle] must not previously have been passed to [rust_future_free]
/// - The `T` param must correctly correspond to the [rust_future_new] call.  It must
///   be `<Output as FfiConverter<UT>>::ReturnType`
pub unsafe fn rust_future_complete<T: FfiDefault>(
    handle: RustFutureHandle,
    out_status: &mut RustCallStatus,
) -> T {
    let future = &*(handle.0 as *mut Arc<dyn RustFutureFfi>);
    let mut return_value = T::ffi_default();
    let out_return = std::mem::transmute::<&mut T, &mut ()>(&mut return_value);
    future.ffi_complete(out_return, out_status);
    return_value
}

/// Free a Rust future, dropping the strong reference and releasing all references held by the
/// future.
///
/// # Safety
///
/// The [RustFutureHandle] must not previously have been passed to [rust_future_free]
pub unsafe fn rust_future_free(handle: RustFutureHandle) {
    let future = Box::from_raw(handle.0 as *mut Arc<dyn RustFutureFfi>);
    future.ffi_free()
}

/// Thread-safe storage for a RustFutureContinuation
///
/// The basic guarantee is that all continuations passed to [Self::store] are called exactly once
/// (assuming that [Self::try_call_continuation] is called after the last store).  This enables us to
/// uphold the [rust_future_poll] guarantee.
///
/// AtomicContinuationCell uses atomic trickery to make all operations thread-safe but non-blocking.
struct AtomicContinuationCell {
    state: AtomicU8,
    stored: UnsafeCell<Option<(RustFutureContinuation, *const ())>>,
}

impl AtomicContinuationCell {
    /// Lock bit
    const STATE_LOCK: u8 = 1 << 0;
    /// Bit signalling that we should call the continuation
    const STATE_NEEDS_CALL: u8 = 1 << 1;
    /// Bit signalling that the RustFuture has been cancelled
    const STATE_CANCELLED: u8 = 1 << 2;

    fn new() -> Self {
        Self {
            state: AtomicU8::new(0),
            stored: UnsafeCell::new(None),
        }
    }

    /// Try to take a lock, optionally setting the other bits
    fn try_lock(&self, extra_bits: u8) -> bool {
        let prev_state = self
            .state
            .fetch_or(Self::STATE_LOCK | extra_bits, Ordering::Acquire);
        (prev_state & Self::STATE_LOCK) == 0
    }

    /// Release a lock, calling any stored continuation
    fn unlock_and_call(&self) {
        self.call_continuation_unchecked();
        self.state.fetch_and(
            !(Self::STATE_LOCK | Self::STATE_NEEDS_CALL),
            Ordering::Release,
        );
    }

    /// Release a lock with the intention of keeping a stored continuation
    ///
    /// However, if another thread set the STATE_NEEDS_CALL or STATE_READY bit, then instead call
    /// the stored continuation for them.
    fn unlock_and_store(&self, new_continuation: RustFutureContinuation, data: *const ()) {
        // Set the continuation
        let stored = unsafe { &mut *self.stored.get() };
        if stored.is_some() {
            log::error!("AtomicContinuationCell::unlock_and_store: continuation already set");
            self.call_continuation_unchecked();
        }
        *stored = Some((new_continuation, data));

        match self
            .state
            .compare_exchange(Self::STATE_LOCK, 0, Ordering::Release, Ordering::Relaxed)
        {
            // Success!
            Ok(_) => (),
            Err(_) => {
                // Another thread set the STATE_NEEDS_CALL or STATE_READY bit, so we should call the
                // continuation for them.
                self.call_continuation_unchecked();
                // We can now unlock unconditionally
                self.state.fetch_and(
                    !(Self::STATE_LOCK | Self::STATE_NEEDS_CALL),
                    Ordering::Release,
                );
            }
        }
    }

    // Take the data out of self.continuation.  If it was set, then call the continuation.
    //
    // Only call this if you have the lock
    fn call_continuation_unchecked(&self) {
        let stored = unsafe { &mut *self.stored.get() };
        if let Some((continuation, data)) = stored.take() {
            continuation(data, self.poll_code());
        }
    }

    fn try_call_continuation(&self, cancelled: bool) {
        let extra_bits = if cancelled {
            Self::STATE_NEEDS_CALL | Self::STATE_CANCELLED
        } else {
            Self::STATE_NEEDS_CALL
        };
        if self.try_lock(extra_bits) {
            self.unlock_and_call();
        }
    }

    fn store(&self, continuation: RustFutureContinuation, data: *const ()) {
        if self.try_lock(0) {
            self.unlock_and_store(continuation, data);
        } else {
            // Failed to acquire the lock
            //   - If the other thread was calling `try_call_continuation`, that means they locked us out
            //     just before we could store the continuation.
            //   - If the other thread was calling `store`, then something weird happened and
            //     there's already a stored continuation.
            //
            // In either case, call the continuation now.
            continuation(data, self.poll_code());
        }
    }

    fn poll_code(&self) -> RustFuturePoll {
        if self.state.load(Ordering::Relaxed) & Self::STATE_CANCELLED == 0 {
            RustFuturePoll::MaybeReady
        } else {
            RustFuturePoll::Ready
        }
    }

    fn is_cancelled(&self) -> bool {
        self.state.load(Ordering::Relaxed) & Self::STATE_CANCELLED != 0
    }
}

// AtomicContinuationCell is Send + Sync as long the previous code is working correctly.

unsafe impl Send for AtomicContinuationCell {}
unsafe impl Sync for AtomicContinuationCell {}

/// Wraps the actual future we're polling
struct WrappedFuture<F, T, UT>
where
    // See rust_future_new for an explanation of these trait bounds
    F: Future<Output = T> + Send + 'static,
    T: FfiConverter<UT> + Send + 'static,
    UT: Send + 'static,
{
    // Note: this could be a single enum, but that would make it easy to mess up the future pinning
    // guarantee.   For example you might want to call `std::mem::take()` to try to get the result,
    // but if the future happened to be stored that would move and break all internal references.
    future: Option<F>,
    result: Option<Result<T::ReturnType, RustCallStatus>>,
}

impl<F, T, UT> WrappedFuture<F, T, UT>
where
    // See rust_future_new for an explanation of these trait bounds
    F: Future<Output = T> + Send + 'static,
    T: FfiConverter<UT> + Send + 'static,
    UT: Send + 'static,
{
    fn new(future: F) -> Self {
        Self {
            future: Some(future),
            result: None,
        }
    }

    // Poll the future and check if it's ready or not
    fn poll(&mut self, context: &mut Context<'_>) -> bool {
        if self.result.is_some() {
            true
        } else if let Some(future) = &mut self.future {
            // SAFETY: We can call Pin::new_unchecked because:
            //    - This is the only time we get a &mut to `self.future`
            //    - We never poll the future after it's moved (for example by using take())
            //    - We never move RustFuture, which contains us.
            //    - RustFuture is private to this module so no other code can move it.
            let pinned = unsafe { Pin::new_unchecked(future) };
            // Run the poll and lift the result if it's ready
            let mut out_status = RustCallStatus::default();
            let result: Option<Poll<T::ReturnType>> = rust_call_with_out_status(
                &mut out_status,
                // This closure uses a `&mut F` value, which means it's not UnwindSafe by
                // default.  If the future panics, it may be in an invalid state.
                //
                // However, we can safely use `AssertUnwindSafe` since a panic will lead the `None`
                // case below and we will never poll the future again.
                panic::AssertUnwindSafe(|| match pinned.poll(context) {
                    Poll::Pending => Ok(Poll::Pending),
                    Poll::Ready(v) => T::lower_return(v).map(Poll::Ready),
                }),
            );
            match result {
                Some(Poll::Pending) => false,
                Some(Poll::Ready(v)) => {
                    self.future = None;
                    self.result = Some(Ok(v));
                    true
                }
                None => {
                    self.future = None;
                    self.result = Some(Err(out_status));
                    true
                }
            }
        } else {
            log::error!("poll with neither future nor result set");
            true
        }
    }

    fn complete(&mut self, out_return: &mut T::ReturnType, out_status: &mut RustCallStatus) {
        match self.result.take() {
            Some(Ok(v)) => *out_return = v,
            Some(Err(call_status)) => *out_status = call_status,
            None => *out_status = RustCallStatus::cancelled(),
        }
        self.free();
    }

    fn free(&mut self) {
        self.future = None;
        self.result = None;
    }
}

// If F and T are Send, then WrappedFuture is too
//
// Rust will not mark it Send by default when T::ReturnType is a raw pointer.  This is promising
// that we will treat the raw pointer properly, for example by not returning it twice.
unsafe impl<F, T, UT> Send for WrappedFuture<F, T, UT>
where
    // See rust_future_new for an explanation of these trait bounds
    F: Future<Output = T> + Send + 'static,
    T: FfiConverter<UT> + Send + 'static,
    UT: Send + 'static,
{
}

/// Future that the foreign code is awaiting
struct RustFuture<F, T, UT>
where
    // See rust_future_new for an explanation of these trait bounds
    F: Future<Output = T> + Send + 'static,
    T: FfiConverter<UT> + Send + 'static,
    UT: Send + 'static,
{
    // This Mutex should never block if our code is working correctly, since there should not be
    // multiple threads calling [Self::poll] and/or [Self::complete] at the same time.
    future: Mutex<WrappedFuture<F, T, UT>>,
    continuation: AtomicContinuationCell,
    // UT is used as the generic parameter for FfiConverter.
    // Let's model this with PhantomData as a function that inputs a UT value.
    _phantom: PhantomData<fn(UT) -> ()>,
}

impl<F, T, UT> RustFuture<F, T, UT>
where
    // See rust_future_new for an explanation of these trait bounds
    F: Future<Output = T> + Send + 'static,
    T: FfiConverter<UT> + Send + 'static,
    UT: Send + 'static,
{
    fn new(future: F, _tag: UT) -> Arc<Self> {
        Arc::new(Self {
            future: Mutex::new(WrappedFuture::new(future)),
            continuation: AtomicContinuationCell::new(),
            _phantom: PhantomData,
        })
    }

    fn poll(self: Arc<Self>, new_continuation: RustFutureContinuation, data: *const ()) {
        let ready = self.continuation.is_cancelled() || {
            let mut locked = self.future.lock().unwrap();
            let waker: std::task::Waker = Arc::clone(&self).into();
            locked.poll(&mut Context::from_waker(&waker))
        };
        if ready {
            new_continuation(data, RustFuturePoll::Ready);
        } else {
            self.continuation.store(new_continuation, data);
        }
    }

    fn wake(&self) {
        self.continuation.try_call_continuation(false)
    }

    fn cancel(&self) {
        self.continuation.try_call_continuation(true);
    }

    fn complete(&self, return_value: &mut T::ReturnType, call_status: &mut RustCallStatus) {
        self.future
            .lock()
            .unwrap()
            .complete(return_value, call_status)
    }

    fn free(self: Arc<Self>) {
        // Call any leftover continuation callbacks now
        self.continuation.try_call_continuation(true);
        // Ensure we drop our inner future, releasing all held references
        self.future.lock().unwrap().free();
    }
}

impl<F, T, UT> Wake for RustFuture<F, T, UT>
where
    // See rust_future_new for an explanation of these trait bounds
    F: Future<Output = T> + Send + 'static,
    T: FfiConverter<UT> + Send + 'static,
    UT: Send + 'static,
{
    fn wake(self: Arc<Self>) {
        self.deref().wake()
    }

    fn wake_by_ref(self: &Arc<Self>) {
        self.deref().wake()
    }
}

/// RustFuture FFI trait.  This allows `Arc<RustFuture<_, _, _>>` to be cast to
/// `Arc<dyn RustFutureFfi>`, which is needed to implement the public FFI API.  In particular, this
/// allows you to use RustFuture functionality without knowing the concrete Future type, which is
/// unnamable.
#[doc(hidden)]
trait RustFutureFfi {
    fn ffi_poll(self: Arc<Self>, continuation: RustFutureContinuation, data: *const ());
    fn ffi_cancel(&self);
    unsafe fn ffi_complete(&self, out_return: &mut (), call_status: &mut RustCallStatus);
    fn ffi_free(self: Arc<Self>);
}

impl<F, T, UT> RustFutureFfi for RustFuture<F, T, UT>
where
    // See rust_future_new for an explanation of these trait bounds
    F: Future<Output = T> + Send + 'static,
    T: FfiConverter<UT> + Send + 'static,
    UT: Send + 'static,
{
    fn ffi_poll(self: Arc<Self>, continuation: RustFutureContinuation, data: *const ()) {
        self.poll(continuation, data)
    }

    fn ffi_cancel(&self) {
        self.cancel()
    }

    unsafe fn ffi_complete(&self, out_return: &mut (), call_status: &mut RustCallStatus) {
        // Unsafely transmute out_return.  This works as long as the foreign code calls the
        // correct `rust_future_complete_*` function.
        let out_return = std::mem::transmute::<&mut (), &mut T::ReturnType>(out_return);
        self.complete(out_return, call_status)
    }

    fn ffi_free(self: Arc<Self>) {
        self.free();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{test_util::TestError, try_lift_from_rust_buffer, RustBuffer, RustCallStatusCode};
    use once_cell::sync::OnceCell;
    use std::task::Waker;

    // Sender/Receiver pair that we use for testing
    struct Channel {
        result: Option<Result<String, TestError>>,
        waker: Option<Waker>,
    }

    struct Sender(Arc<Mutex<Channel>>);

    impl Sender {
        fn wake(&self) {
            let inner = self.0.lock().unwrap();
            if let Some(waker) = &inner.waker {
                waker.wake_by_ref();
            }
        }

        fn send(&self, value: Result<String, TestError>) {
            let mut inner = self.0.lock().unwrap();
            if inner.result.replace(value).is_some() {
                panic!("value already sent");
            }
            if let Some(waker) = &inner.waker {
                waker.wake_by_ref();
            }
        }
    }

    struct Receiver(Arc<Mutex<Channel>>);

    impl Future for Receiver {
        type Output = Result<String, TestError>;

        fn poll(
            self: Pin<&mut Self>,
            context: &mut Context<'_>,
        ) -> Poll<Result<String, TestError>> {
            let mut inner = self.0.lock().unwrap();
            match &inner.result {
                Some(v) => Poll::Ready(v.clone()),
                None => {
                    inner.waker = Some(context.waker().clone());
                    Poll::Pending
                }
            }
        }
    }

    // Create a sender and rust future that we can use for testing
    fn channel() -> (Sender, Arc<dyn RustFutureFfi>) {
        let channel = Arc::new(Mutex::new(Channel {
            result: None,
            waker: None,
        }));
        let rust_future = RustFuture::new(Receiver(channel.clone()), crate::UniFfiTag);
        (Sender(channel), rust_future)
    }

    /// Poll a Rust future and get an OnceCell that's set when the continuation is called
    fn poll(rust_future: &Arc<dyn RustFutureFfi>) -> OnceCell<RustFuturePoll> {
        let cell = OnceCell::new();
        let cell_ptr = &cell as *const OnceCell<RustFuturePoll> as *const ();
        rust_future.clone().ffi_poll(poll_continuation, cell_ptr);
        cell
    }

    extern "C" fn poll_continuation(data: *const (), code: RustFuturePoll) {
        let cell = unsafe { &*(data as *const OnceCell<RustFuturePoll>) };
        cell.set(code).expect("Error setting OnceCell");
    }

    fn complete(rust_future: Arc<dyn RustFutureFfi>) -> (RustBuffer, RustCallStatus) {
        let mut out_return = RustBuffer::new();
        let mut out_status_code = RustCallStatus::default();
        unsafe {
            rust_future.ffi_complete(
                std::mem::transmute::<_, &mut ()>(&mut out_return),
                &mut out_status_code,
            );
        }
        (out_return, out_status_code)
    }

    #[test]
    fn test_success() {
        let (sender, rust_future) = channel();

        // Test polling the rust future before it's ready
        let continuation_result = poll(&rust_future);
        assert_eq!(continuation_result.get(), None);
        sender.wake();
        assert_eq!(continuation_result.get(), Some(&RustFuturePoll::MaybeReady));

        // Test polling the rust future when it's ready
        let continuation_result = poll(&rust_future);
        assert_eq!(continuation_result.get(), None);
        sender.send(Ok("All done".into()));
        assert_eq!(continuation_result.get(), Some(&RustFuturePoll::MaybeReady));

        // Future polls should immediately return ready
        let continuation_result = poll(&rust_future);
        assert_eq!(continuation_result.get(), Some(&RustFuturePoll::Ready));

        // Complete the future
        let (return_buf, call_status) = complete(rust_future);
        assert_eq!(call_status.code, RustCallStatusCode::Success);
        assert_eq!(
            <String as FfiConverter<crate::UniFfiTag>>::try_lift(return_buf).unwrap(),
            "All done"
        );
    }

    #[test]
    fn test_error() {
        let (sender, rust_future) = channel();

        let continuation_result = poll(&rust_future);
        assert_eq!(continuation_result.get(), None);
        sender.send(Err("Something went wrong".into()));
        assert_eq!(continuation_result.get(), Some(&RustFuturePoll::MaybeReady));

        let continuation_result = poll(&rust_future);
        assert_eq!(continuation_result.get(), Some(&RustFuturePoll::Ready));

        let (_, call_status) = complete(rust_future);
        assert_eq!(call_status.code, RustCallStatusCode::Error);
        unsafe {
            assert_eq!(
                try_lift_from_rust_buffer::<TestError, crate::UniFfiTag>(
                    call_status.error_buf.assume_init()
                )
                .unwrap(),
                TestError::from("Something went wrong"),
            )
        }
    }

    // Once `complete` is called, the inner future should be released, even if wakers still hold a
    // reference to the RustFuture
    #[test]
    fn test_cancel() {
        let (_sender, rust_future) = channel();

        let continuation_result = poll(&rust_future);
        assert_eq!(continuation_result.get(), None);
        rust_future.ffi_cancel();
        // Cancellation should immediately invoke the callback with RustFuturePoll::Ready
        assert_eq!(continuation_result.get(), Some(&RustFuturePoll::Ready));

        // Future polls should immediately invoke the callback with RustFuturePoll::Ready
        let continuation_result = poll(&rust_future);
        assert_eq!(continuation_result.get(), Some(&RustFuturePoll::Ready));

        let (_, call_status) = complete(rust_future);
        assert_eq!(call_status.code, RustCallStatusCode::Cancelled);
    }

    // Once `free` is called, the inner future should be released, even if wakers still hold a
    // reference to the RustFuture
    #[test]
    fn test_release_future() {
        let (sender, rust_future) = channel();
        // Create a weak reference to the channel to use to check if rust_future has dropped its
        // future.
        let channel_weak = Arc::downgrade(&sender.0);
        drop(sender);
        // Create an extra ref to rust_future, simulating a waker that still holds a reference to
        // it
        let rust_future2 = rust_future.clone();

        // Complete the rust future
        rust_future.ffi_free();
        // Even though rust_future is still alive, the channel shouldn't be
        assert!(Arc::strong_count(&rust_future2) > 0);
        assert_eq!(channel_weak.strong_count(), 0);
        assert!(channel_weak.upgrade().is_none());
    }

    // If `free` is called with a continuation still stored, we should call it them then.
    //
    // This shouldn't happen in practice, but it seems like good defensive programming
    #[test]
    fn test_complete_with_stored_continuation() {
        let (_sender, rust_future) = channel();

        let continuation_result = poll(&rust_future);
        rust_future.ffi_free();
        assert_eq!(continuation_result.get(), Some(&RustFuturePoll::Ready));
    }
}
