{%- import "macros.py" as py %}
{%- if let Some(docstring) = module_docstring %}
{{ docstring }}
{%- endif %}

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import platform
{%- for import in imports %}
{{ import }}
{%- endfor %}

# Used for default argument values
_DEFAULT = object() # type: typing.Any

{% include "RustBufferTemplate.py" %}
{% include "Helpers.py" %}
{% include "HandleMap.py" %}
{% include "RustBufferHelper.py" %}

# Contains loading, initialization code, and the FFI Function declarations.
{% include "NamespaceLibraryTemplate.py" %}

# Runtimes loaded:
# {{ "{:?}"|format(runtimes) }}
{%- if runtimes.callback_interface %}
{%- include "CallbackInterfaceRuntime.py" %}
{%- endif %}
{%- if runtimes.async_ %}
{%- include "Async.py" %}
{%- endif %}

# Public interface members begin here.
{%- for protocol in protocols %}
{%- include "Protocol.py" %}
{%- endfor %}

{%- include "Types.py" %}

{%- for func in functions %}
{% call py::define_callable(func) %}
{%- endfor %}

__all__ = [
    "InternalError",
    {%- for export in exports %}
    "{{ export }}",
    {%- endfor %}
]
