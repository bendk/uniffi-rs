/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

mod dataclasses;
mod ffi;
mod functions;
mod interfaces;
mod literal;
mod types;

pub use dataclasses::*;
pub use ffi::*;
pub use functions::*;
pub use interfaces::*;
pub use literal::*;
pub use types::*;

// Re-export UniFFI meta types used in the nodes.
pub use uniffi_meta::{ObjectTraitImplMetadata, Radix};

/// Intermediate representation of the generated bindings for a single crate
///
/// This generated by taking the metadata from the proc-macros and adding derived info, like scaffolding functions.
/// Each bindings generator specializes [BindingsIr] for their language by mutating the nodes and adding data to the `x` fields.
/// See `<https://mozilla.github.io/uniffi-rs/latest/internals/bindings_render_pipeline.html>` for an overview of this.
#[derive(Debug, Clone)]
pub struct BindingsIr {
    pub namespace: String,
    pub crate_docstring: Option<String>,
    pub globals: GlobalNodes,
    pub ffi_definitions: Vec<FfiDefinition>,
    pub type_definitions: Vec<TypeDefinition>,
    pub functions: Vec<Function>,
    pub checksum_checks: Vec<ChecksumCheck>,
}

/// Global definitions
///
/// These are nodes that we always define for the bindings.
/// Putting them here means that we always have easy access them from the bindings generation code.
#[derive(Debug, Clone)]
pub struct GlobalNodes {
    pub ffi_rustbuffer_alloc: FfiFunctionRef,
    pub ffi_rustbuffer_reserve: FfiFunctionRef,
    pub ffi_rustbuffer_free: FfiFunctionRef,
    /// FFI function to check the contract version
    pub ffi_uniffi_contract_version: FfiFunctionRef,
    /// FFI function type for freeing a callback interface
    pub callback_interface_free_type: FfiType,
    /// Always defined String, since it's used to handle Rust call errors
    pub string_type: Type,
    pub contract_version: u32,
}
